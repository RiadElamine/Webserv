@startuml
title CGI Execution Flow (Single Process Model)

actor Client
participant "WebServer <<class>>" as WS
participant "KQueue (Event Loop)" as KQ
participant "Cgi Handler <<class>>" as CGI
participant "CGI Process (forked)" as PROC

group Request Reception
    Client -> WS : HTTP Request (via socket)
    activate WS
    WS -> WS : acceptConnection() (if new client)
    WS -> KQ : Register READ event
    KQ --> WS : Read Event (client_fd)
    WS -> WS : parseHttpRequest()
end

group Classification
    WS -> WS : isCgi(request)
end

alt CGI Request == true

    group CGI Initialization
        WS -> CGI : newCgiInstance()
        activate CGI
        CGI -> CGI : initializeCgiVariables(cgi_dir)
        CGI -> CGI : generateRandomFilename(cgi_stdout)
        CGI -> CGI : openCgiOutputFile(cgi_stdout)
    end

    group CGI Execution
        CGI -> PROC : fork()
        activate PROC
        
        alt Child Process (PROC)
            PROC -> PROC : changeToCgiDirectory()
            PROC -> PROC : setupCgiPipes()
            alt Setup CGI Pipes
                PROC -> PROC : hasRequestBody()
                alt hasRequestBody == true
                    PROC -> PROC : open body pipe for reading (cgi_stdin)
                    PROC -> PROC : setNonBlockCloexec(cgi_stdin)
                    PROC -> PROC : Redirect cgi_stdin to read end of body pipe
                end
                PROC -> PROC : close unused pipe ends (cgi_stdout)
                PROC -> PROC : open body pipe for writing (cgi_stdout)
                PROC -> PROC : setNonBlockCloexec(cgi_stdout)
                PROC -> PROC : Redirect stdout to cgi_stdout
            end
            PROC -> PROC : buildCgiEnv()
            PROC -> PROC : buildCgiArgs()
            PROC -> PROC : runExecve()
        else Parent Process (CGI)
            CGI -> CGI : setNonBlock(cgi_stdout)
            CGI -> CGI : setupParentProcessEvents()
            alt setupParentProcessEvents 
                CGI -> KQ : AddEvent for cgi_stdout (read, timeout)
                CGI -> KQ : AddEvent for cgi_process (exit)
                CGI -> KQ : Disable client events (read, timeout)
            end
        end
        Deactivate CGI
    end

    group Read CGI Output
        KQ --> WS : Read event (cgi_stdout)
        WS -> CGI : _readCgiOutput()
        activate CGI
        CGI -> CGI : read(cgi_stdout)
        alt Read successful
            group Response preparation
                CGI -> CGI : Process output
                alt Process CGI output
                    CGI -> CGI : parsingHeadersAndbody()
                    CGI -> CGI : is_CGI_stdout_complete()
                    alt Output complete
                        CGI -> CGI : mark stdout_done = true
                        CGI -> KQ : Disable READ/TIMEOUT (cgi_stdout)
                    else Partial output
                        CGI -> KQ : Reset TIMEOUT (cgi_stdout)
                    end
                end
            end
        else Read failed
            CGI -> WS : mark client as DISCONNECTED
        end
        Deactivate CGI
    end

    group Process Termination
        KQ --> WS : Process exit event (EVFILT_PROC)
        deactivate PROC
        WS -> CGI : handleCgiCompletion()
        Activate CGI
        CGI -> CGI : waitpid(cgi_pid, &status, 0)
        
        group Response Preparation
            alt (Normal Exit && Stdout done)
                CGI -> CGI : finalizeCgiProcess(Doesnt_fail)
            else CGI exited with error
                CGI -> CGI : finalizeCgiProcess(Bad_Gateway)
            end
            alt Finalization
                alt Normal Exit (overiad status)
                    CGI -> CGI : Do nothing (No_Error)
                else
                    CGI -> CGI : Set Status (Bad_Gateway)
                end
                CGI -> KQ : Enable WRITE/TIMEOUT (client_fd)
                CGI -> KQ : Disable READ (client_fd)
                CGI -> KQ : Delete PROC event
                CGI -> KQ : Delete READ/TIMEOUT (cgi_stdout)
            end
        end
        deactivate CGI
    end

    group Response Transmission
        KQ --> WS : Write Event (client_fd)
        WS -> WS : prepareFinalResponse()
        WS -> WS : determine response method

        alt CGI provided Content-Length
            WS -> WS : send headers with Content-Length
        else No Content-Length from CGI
            WS -> WS : send headers with Transfer-Encoding: chunked
        end
        WS -> Client : send(CGI response)
        alt successful
            WS -> WS : Check_finish_Sending()
            break All Data Sent
                WS -> WS : Set Connection_status = DISCONNECTED
            end
        else Send Failure
            WS -> WS : Set Conection_status = DISCONNECTED
        end
    end

    group Cleanup
        WS -> WS : close_connection()
        alt close connection (Connection_status == DISCONNECTED)
           WS -> KQ : remove client events
           WS -> WS : remove CGI object
            alt Cgi Destructor Called (~Cgi)
                WS -> CGI : ~Cgi()  // Object destruction
                activate CGI

                alt cgi_stdout is_open()
                    CGI -> CGI : close(cgi_stdout)
                end

                alt cgi_stdin is_open()
                    CGI -> CGI : close(cgi_stdin)
                end

                alt cgi_pid is_still_active()
                    CGI -> PROC : kill(cgi_pid, SIGKILL)
                    CGI -> PROC : waitpid(cgi_pid, &status, WNOHANG)
                end

                CGI -> WS : destructor cleanup complete
                deactivate CGI
            end
           WS -> WS : close (client_fd)
        end
    end

else Normal request (non-CGI)
    group Normal HTTP Response
        WS -> WS : generate normal response
        WS -> KQ : EV_DISABLE READ, EV_ENABLE WRITE (client_fd)
        KQ --> WS : Write Event (client_fd)
        WS -> Client : send(normal response)
        WS -> WS : Set Conection_status = DISCONNECTED
        WS -> WS : close_connection()
    end
end

deactivate WS
@enduml

